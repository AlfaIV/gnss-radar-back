// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/Gokert/gnss-radar/internal/pkg/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AuthorizationMutations() AuthorizationMutationsResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthcheckOutput struct {
		UserInfo func(childComplexity int) int
	}

	AuthorizationMutations struct {
		Logout func(childComplexity int, input *model.LogoutInput) int
		Signin func(childComplexity int, input model.SigninInput) int
		Signup func(childComplexity int, input model.SignupInput) int
	}

	CoordsResults struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
		Z func(childComplexity int) int
	}

	GNSS struct {
		Coordinates   func(childComplexity int) int
		ID            func(childComplexity int) int
		SatelliteID   func(childComplexity int) int
		SatelliteName func(childComplexity int) int
	}

	GNSSPagination struct {
		Items func(childComplexity int) int
	}

	LogoutOutput struct {
		Empty func(childComplexity int) int
	}

	Mutation struct {
		Authorization func(childComplexity int) int
	}

	Query struct {
		Authcheck          func(childComplexity int, input *model.AuthcheckInput) int
		Errors             func(childComplexity int) int
		Listgnss           func(childComplexity int, filter model.GNSSFilter) int
		__resolve__service func(childComplexity int) int
	}

	SigninOutput struct {
		UserInfo func(childComplexity int) int
	}

	SignupOutput struct {
		UserInfo func(childComplexity int) int
	}

	User struct {
		ID    func(childComplexity int) int
		Login func(childComplexity int) int
		Role  func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthcheckOutput.userInfo":
		if e.complexity.AuthcheckOutput.UserInfo == nil {
			break
		}

		return e.complexity.AuthcheckOutput.UserInfo(childComplexity), true

	case "AuthorizationMutations.logout":
		if e.complexity.AuthorizationMutations.Logout == nil {
			break
		}

		args, err := ec.field_AuthorizationMutations_logout_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthorizationMutations.Logout(childComplexity, args["input"].(*model.LogoutInput)), true

	case "AuthorizationMutations.signin":
		if e.complexity.AuthorizationMutations.Signin == nil {
			break
		}

		args, err := ec.field_AuthorizationMutations_signin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthorizationMutations.Signin(childComplexity, args["input"].(model.SigninInput)), true

	case "AuthorizationMutations.signup":
		if e.complexity.AuthorizationMutations.Signup == nil {
			break
		}

		args, err := ec.field_AuthorizationMutations_signup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthorizationMutations.Signup(childComplexity, args["input"].(model.SignupInput)), true

	case "CoordsResults.X":
		if e.complexity.CoordsResults.X == nil {
			break
		}

		return e.complexity.CoordsResults.X(childComplexity), true

	case "CoordsResults.Y":
		if e.complexity.CoordsResults.Y == nil {
			break
		}

		return e.complexity.CoordsResults.Y(childComplexity), true

	case "CoordsResults.Z":
		if e.complexity.CoordsResults.Z == nil {
			break
		}

		return e.complexity.CoordsResults.Z(childComplexity), true

	case "GNSS.Coordinates":
		if e.complexity.GNSS.Coordinates == nil {
			break
		}

		return e.complexity.GNSS.Coordinates(childComplexity), true

	case "GNSS.Id":
		if e.complexity.GNSS.ID == nil {
			break
		}

		return e.complexity.GNSS.ID(childComplexity), true

	case "GNSS.SatelliteId":
		if e.complexity.GNSS.SatelliteID == nil {
			break
		}

		return e.complexity.GNSS.SatelliteID(childComplexity), true

	case "GNSS.SatelliteName":
		if e.complexity.GNSS.SatelliteName == nil {
			break
		}

		return e.complexity.GNSS.SatelliteName(childComplexity), true

	case "GNSSPagination.items":
		if e.complexity.GNSSPagination.Items == nil {
			break
		}

		return e.complexity.GNSSPagination.Items(childComplexity), true

	case "LogoutOutput._empty":
		if e.complexity.LogoutOutput.Empty == nil {
			break
		}

		return e.complexity.LogoutOutput.Empty(childComplexity), true

	case "Mutation.authorization":
		if e.complexity.Mutation.Authorization == nil {
			break
		}

		return e.complexity.Mutation.Authorization(childComplexity), true

	case "Query.authcheck":
		if e.complexity.Query.Authcheck == nil {
			break
		}

		args, err := ec.field_Query_authcheck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authcheck(childComplexity, args["input"].(*model.AuthcheckInput)), true

	case "Query.errors":
		if e.complexity.Query.Errors == nil {
			break
		}

		return e.complexity.Query.Errors(childComplexity), true

	case "Query.listgnss":
		if e.complexity.Query.Listgnss == nil {
			break
		}

		args, err := ec.field_Query_listgnss_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Listgnss(childComplexity, args["filter"].(model.GNSSFilter)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "SigninOutput.userInfo":
		if e.complexity.SigninOutput.UserInfo == nil {
			break
		}

		return e.complexity.SigninOutput.UserInfo(childComplexity), true

	case "SignupOutput.userInfo":
		if e.complexity.SignupOutput.UserInfo == nil {
			break
		}

		return e.complexity.SignupOutput.UserInfo(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.login":
		if e.complexity.User.Login == nil {
			break
		}

		return e.complexity.User.Login(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAuthcheckInput,
		ec.unmarshalInputCoordsInput,
		ec.unmarshalInputGNSSFilter,
		ec.unmarshalInputLogoutInput,
		ec.unmarshalInputSigninInput,
		ec.unmarshalInputSignupInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../api/graphql/directives/goField.graphql", Input: `"""
GraphQL converter
"""
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION`, BuiltIn: false},
	{Name: "../../../../api/graphql/enums/enums.graphql", Input: `scalar Empty`, BuiltIn: false},
	{Name: "../../../../api/graphql/enums/errors.graphql", Input: `""" Бизнес ошибки """
enum Error {
    """ Уже cуществует """
    ALREADY_EXISTS
    """ Не авторизован """
    NOT_AUTHORIZED
    """ Не найден"""
    NOT_FOUND
    """ Нет прав """
    PERMISSION_DENIED
    """ Ошибка сервера """
    INTERNAL_ERROR
    """ Ошибка запроса """
    BAD_REQUEST
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/mutation/authorization.graphql", Input: `extend type Mutation {
    """ Мутации связанные с авторизацией """
    authorization: AuthorizationMutations!
}

""" Мутации связанные с авторизацией """
type AuthorizationMutations {
    """ Регистрация """
    signup(input: SignupInput!): SignupOutput! @goField(forceResolver: true)
    """ Авторизация """
    signin(input: SigninInput!): SigninOutput! @goField(forceResolver: true)
    """ Выход """
    logout(input: LogoutInput): LogoutOutput @goField(forceResolver: true)
}

""" Входные параметры для регистрации"""
input SignupInput {
    login: String!
    password: String!
}

""" Выходные параметры для регистрации """
type SignupOutput {
    """ Информация о юзере """
    userInfo: User!
}

""" Входные параметры для авторизации"""
input SigninInput {
    login: String!
    password: String!
}

""" Выходные параметры для авторизации """
type SigninOutput {
    """ Информация о юзере """
    userInfo: User!
}

""" Выходные параметры для выхода """
input LogoutInput {
    """ Пусто """
    _empty: Empty
}

""" Выходные параметры для выхода """
type LogoutOutput {
    """ Пусто """
    _empty: Empty
}
`, BuiltIn: false},
	{Name: "../../../../api/graphql/query/authorization.graphql", Input: `extend type Query {
    """ Проверка авторизации """
    authcheck(input: AuthcheckInput): AuthcheckOutput
}

""" Выходные параметры для проверки авторизации """
input AuthcheckInput {
    """ Пусто """
    _empty: Empty
}

""" Выходные параметры для проверки авторизации """
type AuthcheckOutput {
    """ Информация о юзере """
    userInfo: User!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/query/gnss.graphql", Input: `extend type Query {
    """ Получить список GNSS """
    listgnss(filter: GNSSFilter!): GNSSPagination!
}

input GNSSFilter {
    """ Фильтр по индетификаторам """
    Coordinates: CoordsInput!
}

type GNSSPagination {
    """ Загруженные элементы """
    items: [GNSS!]
}

input CoordsInput {
    """ Координата X """
    X: String!
    """ Координата Y """
    Y: String!
    """ Координата Z """
    Z: String!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/schema/schema.graphql", Input: `### *** Schema *** ###

schema {
    query: Query
    mutation: Mutation
}

extend schema @link(
    url: "https://specs.apollo.dev/federation/v2.3",
    import: ["@external", "@requires", "@provides", "@key", "@shareable", "@inaccessible", "@tag", "@override", "@composeDirective", "@extends"]
)

### *** Queries *** ###

type Query

### *** Mutations *** ###

type Mutation
`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/errors.graphql", Input: `extend type Query {
    """ Словарь ошибок """
    errors: [Error]!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/gnss.graphql", Input: `type GNSS {
    Id: String!
    """ id спутника """
    SatelliteId: String!
    """ Имя спутника """
    SatelliteName: String!
    """ Координаты спутника """
    Coordinates: CoordsResults!
}

type CoordsResults {
    """ Координата X """
    X: String!
    """ Координата Y """
    Y: String!
    """ Координата Z """
    Z: String!
}
`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/user.graphql", Input: `""" Информация о юзере """
type User {
    id: String!
    login: String!
    role: String!
}`, BuiltIn: false},
	{Name: "../../../../federation/directives.graphql", Input: `
	directive @authenticated on FIELD_DEFINITION | OBJECT | INTERFACE | SCALAR | ENUM
	directive @composeDirective(name: String!) repeatable on SCHEMA
	directive @extends on OBJECT | INTERFACE
	directive @external on OBJECT | FIELD_DEFINITION
	directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @inaccessible on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	directive @interfaceObject on OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @override(from: String!, label: String) on FIELD_DEFINITION
	directive @policy(policies: [[federation__Policy!]!]!) on 
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @provides(fields: FieldSet!) on FIELD_DEFINITION
	directive @requires(fields: FieldSet!) on FIELD_DEFINITION
	directive @requiresScopes(scopes: [[federation__Scope!]!]!) on 
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @shareable repeatable on FIELD_DEFINITION | OBJECT
	directive @tag(name: String!) repeatable on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	scalar _Any
	scalar FieldSet
	scalar federation__Policy
	scalar federation__Scope
`, BuiltIn: true},
	{Name: "../../../../federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
